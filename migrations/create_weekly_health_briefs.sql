-- ============================================
-- MIGRATION: Create Weekly Health Briefs Table
-- ============================================
-- This migration creates the table for storing comprehensive weekly health narratives
-- Generated by LLMs with full storytelling and intelligence features

-- Create the weekly_health_briefs table
CREATE TABLE IF NOT EXISTS weekly_health_briefs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    week_of DATE NOT NULL,  -- Monday of the week
    
    -- Brief components stored as JSONB for flexibility
    greeting JSONB NOT NULL DEFAULT '{}'::jsonb,
    main_story JSONB NOT NULL DEFAULT '{}'::jsonb,
    discoveries JSONB NOT NULL DEFAULT '{}'::jsonb,
    experiments JSONB NOT NULL DEFAULT '{}'::jsonb,
    spotlight JSONB NOT NULL DEFAULT '{}'::jsonb,
    week_stats JSONB NOT NULL DEFAULT '{}'::jsonb,
    looking_ahead JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_opened_at TIMESTAMP WITH TIME ZONE,
    
    -- Ensure only one brief per user per week
    UNIQUE(user_id, week_of)
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_weekly_briefs_user_id ON weekly_health_briefs(user_id);
CREATE INDEX IF NOT EXISTS idx_weekly_briefs_week_of ON weekly_health_briefs(week_of);
CREATE INDEX IF NOT EXISTS idx_weekly_briefs_created_at ON weekly_health_briefs(created_at DESC);

-- Create intelligence cache table (optional, for caching computed scores)
CREATE TABLE IF NOT EXISTS intelligence_cache (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    cache_key VARCHAR(255) NOT NULL,
    data JSONB NOT NULL,
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE,
    
    UNIQUE(user_id, cache_key)
);

-- Create index for cache cleanup
CREATE INDEX IF NOT EXISTS idx_intelligence_cache_expires ON intelligence_cache(expires_at);

-- Create anonymous patterns table for comparative intelligence
CREATE TABLE IF NOT EXISTS anonymous_symptom_patterns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pattern_hash VARCHAR(16) NOT NULL,  -- Hashed pattern identifier
    user_hash VARCHAR(16) NOT NULL,     -- Hashed user identifier (anonymous)
    occurrence_count INT DEFAULT 1,
    last_seen TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(pattern_hash, user_hash)
);

-- Create index for pattern matching
CREATE INDEX IF NOT EXISTS idx_anon_patterns_hash ON anonymous_symptom_patterns(pattern_hash);

-- Enable Row Level Security
ALTER TABLE weekly_health_briefs ENABLE ROW LEVEL SECURITY;
ALTER TABLE intelligence_cache ENABLE ROW LEVEL SECURITY;
-- anonymous_symptom_patterns doesn't need RLS as it's anonymous

-- Create RLS policies for weekly_health_briefs
CREATE POLICY "Users can view their own briefs"
    ON weekly_health_briefs FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own briefs"
    ON weekly_health_briefs FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own briefs"
    ON weekly_health_briefs FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own briefs"
    ON weekly_health_briefs FOR DELETE
    USING (auth.uid() = user_id);

-- Create RLS policies for intelligence_cache
CREATE POLICY "Users can view their own cache"
    ON intelligence_cache FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own cache"
    ON intelligence_cache FOR ALL
    USING (auth.uid() = user_id);

-- Grant permissions
GRANT ALL ON weekly_health_briefs TO authenticated;
GRANT ALL ON intelligence_cache TO authenticated;
GRANT ALL ON anonymous_symptom_patterns TO authenticated;

-- Create function to clean expired cache entries
CREATE OR REPLACE FUNCTION clean_expired_cache()
RETURNS void AS $$
BEGIN
    DELETE FROM intelligence_cache 
    WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

-- Optional: Create a trigger to auto-clean cache (or use cron job)
-- This would need pg_cron extension or external scheduler

-- ============================================
-- NOTES:
-- ============================================
-- 1. Run this migration in Supabase SQL editor
-- 2. The JSONB fields allow flexible schema evolution
-- 3. RLS ensures users can only access their own data
-- 4. Anonymous patterns table enables comparative intelligence
-- 5. Cache table is optional but improves performance
-- ============================================